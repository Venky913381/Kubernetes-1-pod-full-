>
read more on services: https://kubernetes.io/docs/concepts/services-networking/service/

>--------------------------------------------------NodePort----------------------------------------------------

apiVersion: v1
kind: Service 
metadata:
  name: nginxservice
  labels: 
    name: service1
spec:
  type: NodePort
  ports:                                                http://ip:80---->9000---->32000
  - nodePort: 32000  > on node , on nodes port, with web ip / browser / ip:port / this is endpoint
    port: 9000       > on pod , machine port will mapped to this port on pod
    targetPort: 80   > on container, container port
  selector:
    appname: myapp 



apiVersion: v1
kind: Pod
metadata:
  name: servicepod
  labels: 
    appname: myapp
spec: 
  containers:
    - image: coolgourav147/nginx-custom
      imagePullPolicy: Never
      name: servicecontainer 




>--------------------------------------------------ClusterIP---------------------------------------------------


apiVersion: v1
kind: Service 

metadata:
  name: servone
  labels: 
    name: service1

spec:                                  #can be used with above pod too..
  type: ClusterIP
  selector:
    appname: myapp
  ports:
  - name: my-servicee
    port: 9000              > pod port/listening port
    protocol: TCP
                                                  

apiVersion: v1
kind: Pod
metadata:
  name: nginxcustom
  labels: 
    appname: myapp
spec: 
  containers:
    - image: coolgourav147/nginx-custom
      imagePullPolicy: Never
      name: servicecontainer  
      ports:
        - containerPort: 80        > target port
          name: my-service         > service will be available on this port name

>-------------------------------------------------

>kubectl expose <type> <name> --type=<NodePort/ClusterIP> --port=<port> --target-port=<port> --name <svcName>
>kubectl expose pod <podname> --type=<NodePort/ClusterIP> --port=<port> --target-port=<port> --name <svcName>

>kubectl apply -f <filename.yaml>  / --dry-run=client
>kubectl get service/svc    -o wide / --show-labels

>kubectl port-forward --address 0.0.0.0 svc/<serviceName> <PortOnHost>:<PortOnPod>
>kubectl port-forward --address 0.0.0.0 svc/<Service-Name> --namespace <NameSpace Name> Machine/HostPort:PodPort

>curl <servicename>.<ns_name>.svc.cluster.local   ---> to access service in another namespace


>----------------------------------------------------

apiVersion: v1
kind: Service 
metadata:
  name: nginxservice
  labels: 
    name: service1
spec:
  type: NodePort

  ports:                                                http://ip:32000---->9000---->80
  - nodePort: 32000 
    port: 9000      
    targetPort: 80  
    name: my-service
    protocol: tcp
  selector:
    appname: myapp 


>-------------------------------------------------------------

>1) http://ip:8080 ---->9000---->32000
>2) http://ip:8080 ---->9000---->my-service

  ports:                                               
  - nodePort: 8080
    port: 9000      
    targetPort: 32000  

    name: my-service
    protocol: tcp   

> for using "name" container specs must mentioned the Port attributes with containerport and its name in container
> spec as below.....
ports:
- containerPort: 32000        
  name: my-service      


>---------------------------------------------------------------------------------------------------------------

> Read_More_

  1. NodePort      (expose service out of cluser)
  2. LoadBalancer  (expose service out of cluser)
  3. ClusterIP     (expose service only within cluser)
  4. External Name Service
  5. Headless Service
  6. External IP Service

  7. Port Forwarding

  8. Ingress/Ingress_Resources/Ingress_Rule
  9. Ingress Controller 
  
>---------------------------------------------------------------------------------------------------------------

>There are two types of applications 1.Stateless application  and  2.Statefull application.

Stateless : it will do not store anything (data) or retrieve anything, eg . Nginx
Statfull  : this type of application stores state, so whenever application crashes or if any issue arises
            or app lost connection, whenever, it comes back it from the same state as data is stored. 
            this type of application can not always start from scratch.


> Headless Service_

The default behaviour of the k8s is to assign internal ip address to the service.
Through this ip address, the service will proxy all the client requests 
and load balance them to the pods behind it.

If we, DNS query the service name via utilities like nslookup, k8s returns the service but not the ip's 
of the pod it manages.

if we are running the single instance of the database pod like mangodb , 
we do not need to load balalnce as only one replica is available. Also, we need the dns query of service 
name to return the ip address of mangodb pod but not of service.

to achieve this , we explicitly set the '.spec.clusterIP' of the service to 'None' to instruct k8s not to
assign any IP to the service  or to Load balance the requests. 
This type of service is knows as Headless Service.

if a headless service manages more than one pod, service dns name will return a lists of pods managed
by the service. The requests will accept the first IP address returned.

One of the misconception with Headless service is that, it do not Load Balances the request.
Even though headless service return the ip addresses of the pods, it will still load balances the 
requests to the pods and this type of load balancing is called as DNS ROUND ROBIN LOAD BALANCING.
> Headless service will Not always forward the reuest to first pod.

>curl <headless_service_name>:<container_port>  ---> this request is directaly forwaed to backend pod through
>    DNS ROUND ROBIN LOAD BALANCING mechanism and for each dns quesy/request it will result in new ip address
>    as headless service is load balancing the requests. 

>However, headless service , whenused with StatefulSets provides a 
>unique identity to each pod managed by StatefulSet


>Headless services are more useful when_
1. Pod to pod communication.
>   pod to pod communication , where we do not wants request to be load balance by service and insted of 
>   returning the service ip, we wants to dynamically fetch the ips of pods to be return.
2. Master-slave configuration, where slaves needs to be aware of the mastrer pod like Clustered databases.



>a headless service is a service with service ip but , insted of load balancing it will return the ips of our
>associated pods, this allows us to interact directaly with pods insted of proxy. it is as simple as specifying
>None for '.spec.clusterIP' and can be utilized with or without selectors.

>Headless service allows us to reach pod directaly, rather than the service acting as a load balancer or
>proxy. this can have many use cases.


apiVersion : v1
kind: Service 
metadata:
  name: headless-service

spec:

  clusterIP: None  <------- explicitly, declare the ClusterIP as None

  ports: 
    - name: http 
      port: 80
      targetPort: 5000
      protocol: TCP
  selector: 
      app: frontend    

>headless services are needed for stateful set application.

>---------------------------------------------------------------------------------------------------------------

>Ingress Controller 
>Ingress Resources         #check ingress yaml file.